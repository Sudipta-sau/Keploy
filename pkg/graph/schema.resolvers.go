package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"
	"go.keploy.io/server/v2/utils"
	"go.uber.org/zap"

	"go.keploy.io/server/v2/pkg/graph/model"
)

// Start is the resolver for the start field.
func (r *mutationResolver) Start(ctx context.Context) (*model.TestRunInfo, error) {
	if r.Resolver == nil {
		err := fmt.Errorf(utils.Emoji + "failed to get Resolver")
		return nil, err
	}

	testRunId, appId, err := r.replay.BootReplay(ctx)
	if err != nil {
		r.logger.Error("failed to boot replay", zap.Error(err))
		return nil, err
	}
	return &model.TestRunInfo{
		TestRunID: testRunId,
		AppID:     int(appId),
	}, nil
}

// TestSets is the resolver for the testSets field.
func (r *queryResolver) TestSets(ctx context.Context) ([]string, error) {
	if r.Resolver == nil {
		err := fmt.Errorf(utils.Emoji + "failed to get Resolver")
		return nil, err
	}

	ids, err := r.replay.GetAllTestSetIds(ctx)
	if err != nil {
		r.logger.Error("failed to get all test set ids", zap.Error(err))
		return nil, err
	}
	return ids, nil
}

// RunTestSet is the resolver for the runTestSet field.
func (r *mutationResolver) RunTestSet(ctx context.Context, testSetID string, testRunID string, appID int) (string, error) {
	if r.Resolver == nil {
		err := fmt.Errorf(utils.Emoji + "failed to get Resolver")
		return "", err
	}

	status, err := r.replay.RunTestSet(ctx, testSetID, testRunID, uint64(appID), true)
	if err != nil {
		return "", err
	}
	return string(status), nil
}

// TestSetStatus is the resolver for the testSetStatus field.
func (r *queryResolver) TestSetStatus(ctx context.Context, testRunID string, testSetID string) (*model.TestSetStatus, error) {
	if r.Resolver == nil {
		err := fmt.Errorf(utils.Emoji + "failed to get Resolver")
		return nil, err
	}
	status, err := r.replay.GetTestSetStatus(ctx, testRunID, testSetID)
	if err != nil {
		return nil, err
	}
	return &model.TestSetStatus{
		Status: string(status),
	}, nil
}

// Stop is the resolver for the stop field.
func (r *queryResolver) Stop(ctx context.Context) (bool, error) {
	if r.Resolver == nil {
		err := fmt.Errorf(utils.Emoji + "failed to get Resolver")
		return false, err
	}
	err := utils.Stop(r.logger, "stopping the test run")
	if err != nil {
		r.logger.Error("failed to stop the test run", zap.Error(err))
		return false, err
	}
	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
