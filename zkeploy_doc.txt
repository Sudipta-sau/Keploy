-> main.go: initialises the sentry and cmd execution

-> /cmd: deals with the cli commands
	-root: a. has root struct contain logger and array of plugins (interface with getCmd method)
		   b. create root, set Up logger, modify the sentry, delete logs, check debug flags, and start excute method (keploy)

	-record: a. cli for record, records the api calls and store in tests.
	
	-test: a. cli for test, tests the recorded api calls and store in testsReports.

	-serve: cli for serve, run the keploy server to expose test apis.
	 
...and more.


-> /pkg
   
  -> /test: services regarding test
		a. util: contains interfaces for `initialiseRunTestSetReturn`, `InitialiseTestReturn`, `TestConfig`, `RunTestSetConfig`, `SimulateRequestConfig`, `FetchTestResultsConfig` along with other func like flatten nested map in dot.. keys, compare headers, sort and filter mocks.

		b. match: has Match func to check actual body and response body.

		c. output: diff functions to output the test result in cli

		d. test: With test func where we `initialize test`, [i.e deals with go coverage if provided, then set stop syscalls with channel, fetchRecorede test case, initiate the hook and finally loadedhooks send proxy ip and port to ebpf],
			then we check if provided testset match with recorded testset with range function, we get testcase with `sessionIndex` ad handle noice, we then run 
			`RunTestSet`[here we initial `run test case` [i.e we read test cases, then read testcase mock and config mock and pass them to loaded hook, then start user app, store testReports and write testReport and then logs remaining data]
			it takes the initialized values sort the keploy and non-keply mocks and configs and then we `simulateRequest`[simulate the request given with config, it uses `testHttp` it return if test passed bool and testResult struct] 
			then we `fetch testresults` [store the result of the testrun as test-report and return testRunStatus] it return this status to test func] it checks the testRunStatus with cases and set test result, then deals with coverage () if present, 
			3finally stops the ebpf listner and proxy server and end.

  -> /serve: provides an interface to run a graphql server used in running keploy tests along with unit tests of the application
		a. 